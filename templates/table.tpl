// This file was generated by go-dao-code-gen, 
// you can modify it to be more suitable. 

package {{ .Pkg }}

import (
	"context"
	"errors"
	"time"
    "fmt"

	"github.com/yangsai7/go-mysql"
	"github.com/yangsai7/go-sqlbuilder"
)

const ( // {{ .TableLowerCamelIdent }}TableName specifies the table name.
    {{ .TableUpperCamelIdent }}TableName = "{{ .Table }}"
    // Max{{ .TableUpperCamelIdent }}Limit specifies limit of insert and select operations.
	Max{{ .TableUpperCamelIdent }}Limit int = 1000
)

var (
	{{ .TableLowerCamelIdent }}Alias        {{ .TableUpperCamelIdent }}Alias
	{{ .TableLowerCamelIdent }}Fields       []string
	{{ .TableLowerCamelIdent }}UpdateFields map[string]struct{}    // Fields are allowed to be modified
	{{ .TableLowerCamelIdent }}OmitEmptyFields map[string]struct{} // Fields skipped when modifying with empty value
)

// {{ .TableUpperCamelIdent }}Dao specifies the dao object.
type {{ .TableUpperCamelIdent }}Dao struct {
	db          *sql.DB
    forceMaster bool
    *{{ .TableUpperCamelIdent }}Alias
}

// {{ .TableUpperCamelIdent }}Alias alias of fields in table {{ .Table }}. 
type {{ .TableUpperCamelIdent }}Alias struct {
{{- range .Attrs }}
        {{ .Name }} string // {{ .Tag }}
{{- end }}
}

// {{ .TableUpperCamelIdent }}Entity {{ .Table }} table mapping, 
// Please manually remove the update tag in the field that is not allowed to be modified.
type {{ .TableUpperCamelIdent }}Entity struct {
{{- range .Attrs }}
        {{ .Name }} {{ .Type }} `db:"{{ .Tag }}" {{ if not .IsPk -}}fieldtag:"update"{{- end }}` {{ if .Comment -}}// {{ .Comment }} {{- end }} 
{{- end }}
}

func init() {
    InitTableAlias({{ .TableUpperCamelIdent }}Entity{}, &{{ .TableLowerCamelIdent }}Alias)
	InitTableFields({{ .TableUpperCamelIdent }}Entity{}, &{{ .TableLowerCamelIdent }}Fields)
	{{ .TableLowerCamelIdent }}UpdateFields = make(map[string]struct{}, len({{ .TableLowerCamelIdent }}Fields))
	InitTableUpdateFields({{ .TableUpperCamelIdent }}Entity{}, {{ .TableLowerCamelIdent }}UpdateFields)
	{{ .TableLowerCamelIdent }}OmitEmptyFields = make(map[string]struct{})
	InitTableOmitEmptyFields({{ .TableUpperCamelIdent }}Entity{}, {{ .TableLowerCamelIdent }}OmitEmptyFields)
}

// New{{ .TableUpperCamelIdent }}Dao create a new table object.
func New{{ .TableUpperCamelIdent }}Dao() *{{ .TableUpperCamelIdent }}Dao {
	return &{{ .TableUpperCamelIdent }}Dao{
		db: globalDB,
        {{ .TableUpperCamelIdent }}Alias: &{{ .TableLowerCamelIdent }}Alias,
	}
}

// Insert insert one data record.
func (d *{{ .TableUpperCamelIdent }}Dao) Insert(ctx context.Context, values map[string]interface{})(lastInsertID int64, err error){
    if len(values) == 0 {
        return lastInsertID, errors.New("param values cannot be empty")
    }
    cols := make([]string, 0, len(values))
    vals := make([]interface{}, 0, len(values))
    for _, field := range {{ .TableLowerCamelIdent }}Fields {
        if val, ok := values[field]; ok {
            cols = append(cols, field)
            vals = append(vals, val)
        } 
    }
    if len(cols) == 0 {
        return lastInsertID, errors.New("no valid field data found")
    }

	// Here you can add some default values for the fields.
	// example:
	// curTime := time.Now().Unix()
    // if _, ok := values["create_time"]; !ok {
        // cols = append(cols, "create_time")
        // vals = append(vals, curTime)
    // }
    // if _, ok := values["update_time"]; !ok {
        // cols = append(cols, "update_time")
        // vals = append(vals, curTime)
    // }
    ib := sqlbuilder.NewInsertBuilder()
    ib.InsertInto({{ .TableUpperCamelIdent }}TableName)
    ib.Cols(cols...)
    ib.Values(vals...)
    sql, args := ib.Build()
	result, err := d.db.Exec(sql,args...)
	if err != nil{
        // log error
		return lastInsertID,err 
	}
	return result.LastInsertId()
}

// InsertMany insert multiple data records.
func (d *{{ .TableUpperCamelIdent }}Dao) InsertMany(ctx context.Context, valueList []map[string]interface{}) (err error) {
	if len(valueList) == 0 {
		return
	}
    if len(valueList) > Max{{ .TableUpperCamelIdent }}Limit {
        return fmt.Errorf("received %d data, exceeding the maximum %d limit", len(valueList), Max{{ .TableUpperCamelIdent }}Limit)
    }
	var cols []string
	var valsList [][]interface{}
	for index, values := range valueList {
		if len(values) == 0 {
			return errors.New("param values cannot be empty")
		}
		vals := make([]interface{}, 0, len(values))
		for _, field := range {{ .TableLowerCamelIdent }}Fields {
			if val, ok := values[field]; ok {
				if index == 0 {
					cols = append(cols, field)
				}
				vals = append(vals, val)
			}
		}
		valsList = append(valsList, vals)
	}
	if len(cols) == 0 {
		return errors.New("no valid field data found")
	}
    // Add default columns.
    // var hasAddCreate, hasAddUpdate bool
    // if _, ok := valueList[0]["create_time"]; !ok {
    //     cols = append(cols, "create_time")
    //     hasAddCreate = true
    // }
    // if _, ok := valueList[0]["update_time"]; !ok {
    //     cols = append(cols, "update_time")
    //     hasAddUpdate = true
    // }
	ib := sqlbuilder.NewInsertBuilder()
	ib.InsertInto({{ .TableUpperCamelIdent }}TableName)
	ib.Cols(cols...)
	// curTime := time.Now().Unix()
	for _, vals := range valsList {
        // Add default values.
        // if hasAddCreate {
        //     vals = append(vals, curTime)
        // }
        // if hasAddUpdate {
        //     vals = append(vals, curTime)
        // }
		ib.Values(vals...)
	}
	sql, args := ib.Build()
	_, err = d.db.Exec(sql, args...)
	if err != nil {
		return err
	}
	return nil
}


// Get one data record that meets the query criteria
func (d *{{ .TableUpperCamelIdent }}Dao) Get(ctx context.Context, conds ...{{ .TableUpperCamelIdent }}Cond) ({{ .TableLowerCamelIdent }}Entity *{{ .TableUpperCamelIdent }}Entity, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select({{ .TableLowerCamelIdent }}Fields...)
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
    sb.OrderBy("{{.Primary}}").Desc()
	sb.Limit(1)
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdenti + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
		return
	}
	defer rows.Close()
	if rows.Next() {
		{{ .TableLowerCamelIdent }}Entity = &{{ .TableUpperCamelIdent }}Entity{}
		{{ .TableLowerCamelIdent }}Struct := sqlbuilder.NewStruct(new({{ .TableUpperCamelIdent }}Entity))
		err = rows.Scan({{ .TableLowerCamelIdent }}Struct.Addr({{ .TableLowerCamelIdent }}Entity)...)
        if err != nil {
            return 
        }
	}
	return
}

// Count total of data record that meets the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Count(ctx context.Context, conds ...{{ .TableUpperCamelIdent }}Cond) (total int, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select("count(*)")
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdenti + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
        // log error
		return
	}
	defer rows.Close()
	if rows.Next() {
		err = rows.Scan(&total)
        if err != nil {
            return 
        }
	}
	return
}

// List multiple data records that meets the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) List(ctx context.Context, limit, offset int, conds ...{{ .TableUpperCamelIdent }}Cond) ({{ .TableLowerCamelIdent }}List []*{{ .TableUpperCamelIdent }}Entity, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select({{ .TableLowerCamelIdent }}Fields...)
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
    sb.OrderBy("{{.Primary}}").Desc()
    if limit <= 0 || limit > Max{{ .TableUpperCamelIdent }}Limit {
    	sb.Limit(Max{{ .TableUpperCamelIdent }}Limit)
    } else {
    	sb.Limit(limit)
    }
    if offset >= 0 {
    	sb.Offset(offset)
    }
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdenti + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
        // log error
		return
	}
	defer rows.Close()
	{{ .TableLowerCamelIdent }}Struct := sqlbuilder.NewStruct(new({{ .TableUpperCamelIdent }}Entity))
	for rows.Next() {
		{{ .TableLowerCamelIdent }}Entity := &{{ .TableUpperCamelIdent }}Entity{}
		err = rows.Scan({{ .TableLowerCamelIdent }}Struct.Addr({{ .TableLowerCamelIdent }}Entity)...)
        if err != nil {
            return 
        }
		{{ .TableLowerCamelIdent }}List = append({{ .TableLowerCamelIdent }}List, {{ .TableLowerCamelIdent }}Entity)
	}
	return
}

// All multiple data records that meets the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) All(ctx context.Context, limit int, conds ...{{ .TableUpperCamelIdent }}Cond) ({{ .TableLowerCamelIdent }}List []*{{ .TableUpperCamelIdent }}Entity, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select({{ .TableLowerCamelIdent }}Fields...)
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
    sb.OrderBy("{{.Primary}}").Desc()
    if limit > 0 {
    	sb.Limit(limit)
    }
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdenti + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
        // log error
		return
	}
	defer rows.Close()
	{{ .TableLowerCamelIdent }}Struct := sqlbuilder.NewStruct(new({{ .TableUpperCamelIdent }}Entity))
	for rows.Next() {
		{{ .TableLowerCamelIdent }}Entity := &{{ .TableUpperCamelIdent }}Entity{}
		err = rows.Scan({{ .TableLowerCamelIdent }}Struct.Addr({{ .TableLowerCamelIdent }}Entity)...)
        if err != nil {
            return 
        }
		{{ .TableLowerCamelIdent }}List = append({{ .TableLowerCamelIdent }}List, {{ .TableLowerCamelIdent }}Entity)
	}
	return
}

// Update is modify the records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Update(ctx context.Context, values map[string]interface{}, conds ...{{ .TableUpperCamelIdent }}Cond) (total int64, err error) {
	if len(conds) == 0 {
		return
	}
	ub := sqlbuilder.NewUpdateBuilder()
	ub.Update({{ .TableUpperCamelIdent }}TableName)
	fieldList := make([]string, 0, len(values))
	for index, val := range values {
		if _, ok := {{ .TableLowerCamelIdent }}UpdateFields[index]; !ok {
			continue
		}
		if _, ok := {{ .TableLowerCamelIdent }}OmitEmptyFields[index]; ok {
			if reflect.ValueOf(val).IsZero() {
				continue
			}
		}
		fieldList = append(fieldList, ub.Assign(index, val))
	}
	values = nil
	if len(fieldList) == 0 {
		return
	}
    // deal update time
	// fieldList = append(fieldList, ub.Assign("modified", time.Now()))
	ub.Set(fieldList...)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&ub.Cond, &o)
	ub.Where(sqlArgs...)
	sql, args := ub.Build()
	result, err := d.db.Exec(sql, args...)
	if err != nil {
        // log error
		return
	}
	return result.RowsAffected()
}

// Delete the records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Delete(ctx context.Context, conds ...{{ .TableUpperCamelIdent }}Cond) (total int64, err error) {
	if len(conds) == 0 {
		return
	}
	db := sqlbuilder.NewDeleteBuilder()
	db.DeleteFrom({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&db.Cond, &o)
	db.Where(sqlArgs...)
	sql, args := db.Build()
	result, err := d.db.Exec(sql, args...)
	if err != nil {
        // log error
		return
	}
	return result.RowsAffected()
}


// ForceMaster add the master identity for operations of the current object. 
func (d *{{ .TableUpperCamelIdent }}Dao) ForceMaster(){
    d.forceMaster = true
}

// DisableForceMaster remove the master identity for operations of the current object. 
func (d *{{ .TableUpperCamelIdent }}Dao) DisableForceMaster(){
    d.forceMaster = false
}

func (d *{{ .TableUpperCamelIdent }}Dao) UseConn(db *sql.DB){
    d.db = db
}

func (d *{{ .TableUpperCamelIdent }}Dao) CloneConn() (db *sql.DB) {
    return d.db
}
